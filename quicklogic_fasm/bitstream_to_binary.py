import argparse
from pathlib import Path
import re

fpga_bin_header = []

# this script will take
# - bitstream file ${TOP}.bit (already in binary format) 
# - mem initialization file "ram.mem" -> convert to binary : meminit.bin
# - iomux binary file ${TOP}_iomux.bin (already generated by the generate constraints step)
# and create a ${TOP}.bin by appending:
# HEADER: <VERSION 4B><BITSTREAM SIZE 4B><BITSTREAM CRC 4B><MEMINIT SIZE 4B><MEMINIT CRC 4B><IOMUX SIZE 4B><IOMUX CRC 4B>
# BITSTREAM BINARY
# MEMINIT BINARY
# IOMUX BINARY


fpga_bin_version = 0x00000001
bitstream_size = 0
bitstream_crc = 0
meminit_size = 0
meminit_crc = 0
iomux_size = 0
iomux_crc = 0
reserved = 0


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Converts QuickLogic bitstream, meminit, iomux to binary"
    )

    parser.add_argument(
        "infile",
        type=Path,
        help="The input file (bitstream)",
    )

    parser.add_argument(
        "outfile",
        type=Path,
        help="The output file (binary)",
    )

    parser.add_argument(
        "iomux",
        nargs='?',
        type=Path,
        help="iomux configuration (binary)",
    )

    args = parser.parse_args()

    # create bytearray for the fpga binary content
    fpga_bin_content_byte_array = bytearray()

    # create bytearray for the fpga binary header
    fpga_bin_header_byte_array = bytearray()

    ############# BITSTREAM BIN #################
    # open the bitstream and add the bytes as-is into the fpga binary
    with open(args.infile, 'rb') as bitstream:
        
        bitstream_size = Path(args.infile).stat().st_size
        fpga_bin_content_byte_array.extend(bitstream.read())
    #############################################

    ############# MEMINIT BIN #################
    # create a meminit bytearray, in the same format as the header array.
    # <BLOCK_START_ADDR 4B><BLOCK_WORDCOUNT 4B><<MEM WORD 4B>xBLOCK_WORDCOUNT> x NUM_BLOCKS

    # initialize the meminit binary byte array
    mem_init_bin_bytearray = bytearray()

    line_parser = re.compile(r'(?P<addr>0x4001[89ab])[xX0-9a-f]+:(?P<data>[xX0-9a-f]+).*')

    # RAM initialization is always generated as ram.mem
    ram_initialization_file_path = Path(args.infile.parent).joinpath("ram.mem")
    
    fp = open(ram_initialization_file_path, 'r')
    
    file_data = fp.readlines()

    wordcount = 0
    prev_addr = None
    curr_addr = ""
    current_block_start_addr = ""
    current_block_memory_words = bytearray()

    for line in file_data:
        linematch = line_parser.match(line)

        if linematch:
            curr_addr = linematch.group('addr')
            curr_data = linematch.group('data')
        else:
            continue

        # the regex pattern ensures that when we move from one block to the next,
        # the curr_addr will change, as we consider only the block level component of addr:
        # 0x4001X -> 0x4001Y is a block transition
        # for each block, we will have the same addr 0x4001X in each consecutive line.
        # each block always starts at 0x4001X000
        # so, we will have block_start_addr (0x4001X000), followed by number of words of memory (4B)
        # and then followed by the actual memory words that will be written in order, starting from
        # the block_start_addr

        if prev_addr == None:
            # we are going to start the first block
            prev_addr = curr_addr
            # reset memory wordcount
            wordcount = 0
            # set the block start addr
            current_block_start_addr = prev_addr + "000"
            # init the memory block byte array
            current_block_memory_words = bytearray()

        if prev_addr != curr_addr:
            # we are going to start a new block
            # save the block_start_address, memory wordcount, followed by the current block memory words

            mem_init_bin_bytearray.extend(int(current_block_start_addr, 16).to_bytes(4, "little"))
            mem_init_bin_bytearray.extend(int(wordcount).to_bytes(4, "little"))
            mem_init_bin_bytearray.extend(current_block_memory_words)
            # update the block addr to new one:
            prev_addr = curr_addr
            # reset memory wordcount
            wordcount = 0
            # set the block start addr
            current_block_start_addr = prev_addr + "000"
            # init the memory block byte array
            current_block_memory_words = bytearray()

        # add the integer data into the memory block bytearray as 4 LE bytes
        current_block_memory_words.extend(int(curr_data, 16).to_bytes(4, "little"))

        # increment memory wordcount for current block
        wordcount += 1

    # at the end of the loop, the last memory block remains to be saved:
    if (wordcount != 0):
        mem_init_bin_bytearray.extend(int(current_block_start_addr, 16).to_bytes(4, "little"))
        mem_init_bin_bytearray.extend(int(wordcount).to_bytes(4, "little"))
        mem_init_bin_bytearray.extend(current_block_memory_words) 
 
    meminit_size = len(mem_init_bin_bytearray)
    # 1024 words x 4B x 4 blocks + 2 words x 4B x 4 blocks (1024 -> mem, 2 -> addr,count)
    #expected_meminit_size = (1024 * 4 * 4) + (2 * 4 * 4)

    # add to the fpga binary
    fpga_bin_content_byte_array.extend(mem_init_bin_bytearray)

    # we will also output this to a separate binary file (useful!)
    meminit_bin_file_path = Path(args.infile.parent).joinpath(args.infile.stem + "_meminit.bin")
    with open(meminit_bin_file_path, 'wb') as meminitbin:
        meminitbin.write(mem_init_bin_bytearray)
    ###########################################
    
    ############# IOMUX BIN ################# 
    # if bitstream file == NAME.bit, then the iomux binary will be generated as:
    # NAME_iomux.bin, use this to locate the iomux binary
    iomuxbin_file_path = Path(args.infile.parent).joinpath(args.infile.stem + "_iomux.bin")
    if (args.iomux):
        iomuxbin_file_path = args.iomux
    iomux_size = Path(iomuxbin_file_path).stat().st_size
    with open(iomuxbin_file_path, 'rb') as iomuxbin:
        fpga_bin_content_byte_array.extend(iomuxbin.read())
    ###########################################

    ######### FINAL FPGA BIN HEADER ##########
    fpga_bin_header_byte_array.extend(int(fpga_bin_version).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(bitstream_size).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(bitstream_crc).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(meminit_size).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(meminit_crc).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(iomux_size).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(iomux_crc).to_bytes(4, "little"))
    fpga_bin_header_byte_array.extend(int(reserved).to_bytes(4, "little"))
    ##########################################
    
    ############# FINAL FPGA BIN #################
    with open(args.outfile, 'wb') as fpgabin:
        # write the header bytes
        fpgabin.write(fpga_bin_header_byte_array)

        # write the content bytes
        fpgabin.write(fpga_bin_content_byte_array)
    print("fpga bin:", args.outfile, args.outfile.stat().st_size, "bytes")
    ###############################################
